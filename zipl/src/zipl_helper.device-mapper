#!/usr/bin/env python3
#
# zipl_helper.device-mapper: print zipl parameters for a device-mapper device
#
# Copyright IBM Corp. 2009, 2017
#
# s390-tools is free software; you can redistribute it and/or modify
# it under the terms of the MIT license. See LICENSE for details.
#
# Depending on the name by which the script is called, it serves one of two
# purposes:
#
# 1. Usage: zipl_helper.device-mapper <target directory> or
#                                     <major:minor of target device>
#
# This tool attempts to obtain zipl parameters for a target directory or
# partition located on a device-mapper device. It assumes that the
# device-mapper table for this device conforms to the following rules:
# - directory is located on a device consisting of a single device-mapper
#   target
# - only linear, mirror and multipath targets are supported
# - supported physical device types are DASD and SCSI devices
# - all of the device which contains the directory must be located on a single
#   physical device (which may be mirrored or accessed through a multipath
#   target)
# - any mirror in the device-mapper setup must include block 0 of the
#   physical device
#
# 2. Usage: chreipl_helper.device-mapper <major:minor of target device>
#
# This tool identifies the physical device which contains the specified
# device-mapper target devices. If the physical device was found, its
# major:minor parameters are printed. Otherwise, the script exits with an
# error message and a non-zero return code.
#

import re
import os
import sys
import stat
import locale
import logging
import subprocess
from itertools import islice
from collections import namedtuple

logger = logging.getLogger(__name__)

SECTOR_SIZE = 512
DASD_PARTN_MASK = 0x03
SCSI_PARTN_MASK = 0x0f

TOOLS = ['dmsetup', 'dasdview', 'blockdev']

TARGET_TYPES = ["linear", "mirror", "multipath"]

Target = namedtuple('Target', ['start', 'length', 'type', 'data'])
TargetData = namedtuple('TargetData', ['major', 'minor', 'start'])

UNRECOG_TABLE_MSG = "Unrecognized device-mapper table format for device '%s'"
UNSUPPORTED_BLOCK_MSG = "Unsupported setup: Block 0 is not mirrored in device '%s'"

def die(msg, *args, **kwargs):
    logger.critical(msg, *args, **kwargs)
    sys.exit(1)


def run_proc(args):
    return subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                            check=True, universal_newlines=True)


def get_device_name(major, minor):
    partitions_match = re.compile(r'^\s*(\d+)\s+(\d+)\s+\d+\s+(\S+)\s*$')
    with open('/proc/partitions', 'r') as f:
        for line in f:
            res = re.match(partitions_match, line)
            if not res:
                continue
            if int(res.group(1)) == major and int(res.group(2)) == minor:
                return res.group(3)
    return "{}:{}".format(major, minor)


# args: <major>:<minor> <start_sector>
# Returns [major, minor, start_sector]
def get_linear_data(dev_name, args):
    res = re.match(r'^(\d+):(\d+)\s+(\d+)$', args)
    if not res:
        die(UNRECOG_TABLE_MSG, dev_name)
    return TargetData(*map(int, res.groups()))


# args: <log_type> <#log_args> <log_arg1>...<log_argN> \
#       <#devs> <device_name_1> <offset_1>...<device name N> <offset N> \
#       <#features> <feature_1>...<feature_N>
# Returns [TargetData1 ... TargetDataN]
def get_mirror_data(dev_name, args):
    try:
        it = iter(args.split())
        next(it) # <log_type>
        nlogs = int(next(it)) # <#log_args>
        it = islice(it, nlogs, None) # log_args*
        ndevs = int(next(it)) # <#devs>

        data = []
        offset = None
        major_minor_match = re.compile(r'^(\d+):(\d+)$')
        for _ in range(ndevs):
            name, doffset = next(it), int(next(it)) # <dev_name_i> <offset_i>
            res = re.match(major_minor_match, name)
            if not res:
                die(UNRECOG_TABLE_MSG, dev_name)
            data.append(TargetData(*map(int, res.groups()), doffset))
            offset = doffset if offset is None else offset
            if doffset != offset:
                die("Unsupported setup: Mirror target on device '%s' "
                    "contains entries with varying sector offsets", dev_name)

        nfeatures = int(next(it)) # <#features>
        if sum(1 for _ in it) != nfeatures:
            die(UNRECOG_TABLE_MSG, dev_name)

        return data
    except (StopIteration, ValueError):
        die(UNRECOG_TABLE_MSG, dev_name)


# args: <start> <length> <type>
#       <#feature_args> <feature_arg1> ... <feature_argN>
#       <#handler_status_args> <handler_status_arg1> ... <handler_status_argN>
#       <#path_groups> <init_group_number>
#         <group_state1> <#ps_status_args> <ps_args1> ... <ps_argsN>
#         <#paths> <#selector_arg>
#           <node1> <active1> <fail_cnt1> <selector_arg1> ... <selector_argN>
def get_multipath_status(device):
    dev = '/dev/{}'.format(device)
    try:
        res = run_proc(['dmsetup', 'status', dev])
    except subprocess.CalledProcessError as e:
        die("No paths found for '%s': 'dmsetup status' failed", device)

    failed = 0
    states = {}
    for line in res.stdout.splitlines():
        # sample output (single line):
        # 0 67108864 multipath \
        #   2 0 0 \
        #   0 \
        #   2 2 \
        #       E 0 \
        #       2 2 \
        #           8:16 F 1 \
        #               0 1 \
        #           8:0 F 1 \
        #               0 1 \
        #       A 0 \
        #       2 2 \
        #           8:32 A 0 \
        #               0 1 \
        #           8:48 A 0 \
        #               0 1
        it = iter(line.split())
        try:
            start = int(next(it))
            length = int(next(it))
            dtype = next(it)

            if dtype != "multipath":
                continue

            cnt = int(next(it)) # <#multipath_feature_args>
            it = islice(it, cnt, None) # multipath_feature_args*
            cnt = int(next(it)) # <#handler_status_args>
            it = islice(it, cnt, None) # handler_status_args*

            ngr = int(next(it))
            ign = int(next(it))
            for _ in range(ngr):
                # group_state: D(isabled), A(ctive), or E(nabled)
                state = next(it)
                cnt = int(next(it)) # <#ps_status_args>
                it = islice(it, cnt, None) # ps_status_args*
                npaths = int(next(it)) # <#paths>
                nsa = int(next(it)) # <#selector_args>
                for _ in range(npaths):
                    node = next(it)
                    active = next(it)
                    fail_cnt = int(next(it))
                    states[node] = active
                    failed += 1 if active != 'A' else 0
                    it = islice(it, nsa, None) # selector_args*
        except StopIteration:
            continue

    if len(states) == 0:
        die("No paths found for '%s'", device)

    if failed == len(states):
        die("All paths for '%s' failed", device)
    elif failed > 0:
        logger.warning("There are one or more failed paths for device '%s'",
                device)

    return states


# args: <#features> <feat1> ... <featN>
#       <#handlers> <handler1> ... <handlerN>
#       <#path_groups> <path_group> <path_selector>
#       <#selector_args> <selector_arg1> ... <selector_argN>
#       <#paths> <#path_args>
#       <path1> <path1_arg1> ... <path1_argN>
#       ...
#       <pathN> <pathN_arg1> ... <pathN_argN>
# Returns: [TargetData1, ..., TargetDataN]
def get_multipath_data(dev_name, args):
    status = get_multipath_status(dev_name)
    major_minor_match = re.compile(r'(\d+):(\d+)')

    data = []
    it = iter(args.split())
    try:
        nfeatures = int(next(it)) # <#features>
        it = islice(it, nfeatures, None) # features*
        nhandlers = int(next(it)) # <#handlers>
        it = islice(it, nhandlers, None) # handlers*
        pgroups = int(next(it)) # <#pathgroups>
        next(it) # pathgroup
        for _ in range(pgroups):
            next(it) # pathselector
            cnt = int(next(it)) # <#selectorargs>
            it = islice(it, cnt, None) # selectorargs*
            npaths = int(next(it))
            np_args = int(next(it))
            for _ in range(npaths):
                p = next(it)
                res = re.match(major_minor_match, p)
                if not res:
                    die(UNRECOG_TABLE_MSG, dev_name)
                major, minor = map(int, res.groups())
                # FIXME: is it possible for 'p' to not be in 'status'?
                if status[p] == 'A':
                    data.append(TargetData(major, minor, 0))
                # Remove deviceargs
                it = islice(it, np_args, None)
    except (StopIteration, ValueError):
        die(UNRECOG_TABLE_MSG, dev_name)

    if len(data) == 0:
        die(UNRECOG_TABLE_MSG, dev_name)

    return data


# Returns: [target1, ..., targetN]
# target: [start, length, type, data]
# data: linear_data|mirror_data|multipath_data
def get_table(major, minor):
    dev_name = get_device_name(major, minor)

    try:
        res = run_proc(["dmsetup", "table", "-j", str(major), "-m", str(minor)])
    except subprocess.CalledProcessError as e:
        return []

    table = []
    handle_data = dict(zip(TARGET_TYPES, [get_linear_data, get_mirror_data,
                                            get_multipath_data]))
    target_match = re.compile(r'^(\d+)\s+(\d+)\s+(\S+)\s+(\S.*)$')
    for line in res.stdout.splitlines():
        r = re.match(target_match, line)
        if not r:
            die(UNRECOG_TABLE_MSG, dev_name)
        start, length, target_type, args = r.groups()

        if target_type not in TARGET_TYPES:
            die("Unrecognized setup: Unsupported device-mapper target "
                "type '%s' for device '%s'", target_type, dev_name)

        data = handle_data[target_type](dev_name, args)
        table.append(Target(int(start), int(length), target_type, data))

    return table


def get_target_major_minor(target):
    data = target.data if target.type == "linear" else target.data[0]
    return data.major, data.minor


def get_target_start(target):
    return target.data.start if target.type == "linear" else \
            target.data[0].start


# Returns (phy_major, phy_minor, phy_offset, target_list)
# target_list: [TargetData1, ..., TargetDataN]
def get_physical_device(major, minor, directory=None):
    table = get_table(major, minor)
    if len(table) == 0:
        die("Could not retrieve device-mapper information for "
            "device '%s'", get_device_name(major, minor))

    # Filesystem must be on a single dm target
    if len(table) != 1:
        die("Unsupported setup: Directory '%s' is located on a "
            "multi-target device-mapper device", directory)

    target = table[0]
    target_list = [(major, minor, target)]
    start = target.start
    length = target.length
    while True:
        # Convert fs_start to offset on parent dm device
        start += get_target_start(target)
        mmaj, mmin = get_target_major_minor(target)
        table = get_table(mmaj, mmin)
        if len(table) == 0: # found non-dm device
            return (mmaj, mmin, start, target_list)

        def in_range(target, start, length):
            return ((target.start + target.length - 1) >= start) and \
                    (target.start <= (start + length - 1))

        # Get target in parent table which contains filesystem
        # We are interested only in targets between start and start+length-1
        table = list(filter(lambda t: in_range(t, start, length), table))
        if len(table) != 1:
            die("Unsupported setup: Could not map directory '%s' to a "
                "single physical device", directory)
        target = table[0]
        target_list.append((mmaj, mmin, target))
        # Convert fs_start to offset on parent target
        start -= target.start


def get_major_minor(filename):
    try:
        dev = os.stat(filename).st_dev
        return os.major(dev), os.minor(dev)
    except:
        die("Could not stat '%s'", filename)


def get_physical_device_dir(directory):
    major, minor = get_major_minor(directory)
    return get_physical_device(major, minor, directory=directory)


# Returns (type, cylinders, heads, sectors)
def get_dasd_info(device):
    cylinder_match = re.compile(r'^number of cylinders.*\s(\d+)\s*$')
    heads_match = re.compile(r'^tracks per cylinder.*\s(\d+)\s*$')
    sectors_match = re.compile(r'^blocks per track.*\s(\d+)\s*$')
    type_match = re.compile(r'^type\s+:\s+(\S+)\s*$')
    format_match = re.compile(r'^format.*\s+dec\s(\d+)\s')

    cyl, heads, sectors, disk_type, dformat = None, None, None, None, None
    try:
        res = run_proc(['dasdview', '-x', device])
        for line in res.stdout.splitlines():
            r = re.match(cylinder_match, line)
            if r:
                cyl = int(r.group(1))
                continue
            r = re.match(heads_match, line)
            if r:
                heads = int(r.group(1))
                continue
            r = re.match(sectors_match, line)
            if r:
                sectors = int(r.group(1))
                continue
            r = re.match(type_match, line)
            if r:
                disk_type = r.group(1)
                continue
            r = re.match(format_match, line)
            if r:
                dformat = int(r.group(1))
                continue
    except subprocess.CalledProcessError as e:
        return None

    if None in [cyl, heads, sectors, disk_type, dformat]:
        return None

    if disk_type == "ECKD":
        disk_type = "LDL" if dformat == 1 else "CDL"

    return (disk_type, cyl, heads, sectors)


def get_partition_start(major, minor):
    ddir = '/sys/dev/block/{}:{}'.format(major, minor)
    if not os.path.isdir(ddir):
        die("Could not determine partition start for '%s'",
            get_device_name(major, minor))

    try:
        with open('{}/start'.format(ddir), 'r') as f:
            return int(f.read())
    except FileNotFoundError:
        return 0


def is_dasd(ttype):
    return ttype in ["CDL", "LDL", "FBA"]


# Return (major, minor) of the base device on which the partition is located
def get_partition_base(dtype, major, minor):
    return (major, minor & (~DASD_PARTN_MASK if is_dasd(dtype) else ~SCSI_PARTN_MASK))


def get_blocksize(device):
    try:
        # FIXME: replace this by proper system call
        r = run_proc(['blockdev', '--getss', device])
        return int(r.stdout)
    except subprocess.CalledProcessError as e:
        return None


def create_temp_device_node(dtype, major, minor):
    for num in range(100):
        name = '/dev/zipl-dm-temp-{:02d}'.format(num)
        if os.path.exists(name):
            continue
        os.mknod(name, dtype|0o600, os.makedev(major, minor))
        return name
    die("Could not create temporary device node in '/dev'")


# Return (type, blocksize, geometry, bootsectors, partstart) for device
def get_device_characteristics(major, minor):
    name = get_device_name(major, minor)
    dev = create_temp_device_node(stat.S_IFBLK, major, minor)
    try:
        blocksize = get_blocksize(dev)
        if blocksize is None:
            die("Could not get block size for %s", name)
        info = get_dasd_info(dev)
        geometry = None
        if info is not None:
            dtype, cyl, heads, sectors = info
            geometry = "{},{},{}".format(cyl,heads,sectors)
            if dtype == "CDL":
                bootsectors = blocksize * sectors / SECTOR_SIZE
            elif dtype == "LDL":
                bootsectors = blocksize * 2 / SECTOR_SIZE
            elif dtype == "FBA":
                # first block contains IPL records
                bootsectors = blocksize / SECTOR_SIZE
        else: # assume SCSI if get_dasd_info failed
            dtype = "SCSI"
            # first block contains IPL records
            bootsectors = blocksize / SECTOR_SIZE
    except:
        raise
    finally:
        os.remove(dev)

    partstart = get_partition_start(major, minor)
    # Convert partition start in sectors to blocks
    partstart = partstart / (blocksize / SECTOR_SIZE)
    return (dtype, blocksize, geometry, bootsectors, partstart)


def check_tools():
    try:
        return sum(map(attrgetter('returncode'),
                    map(subprocess.run, ([c, '--version'] for c in tools)))) == 0
    except:
        return False


# Return (major, minor) for the topmost target in the target list that maps the
# region on (bottom_major, bottom_minor) defined by start and length at offset 0
def get_target_base(bot_major, bot_minor, start, length, target_list):
    top_major, top_minor = bot_major, bot_minor
    for idx, tgt in zip(range(len(target_list)-1, -1, -1), reversed(target_list)):
        major, minor, target = tgt
        if (target.start != 0) or (get_target_start(target) != 0) or \
            (target.length < length):
            # Check for mirrorring between base device and fs device
            mirror = [t for t in target_list[:idx] if t[2].type == "mirror"]
            if len(mirror) > 0:
                major, minor, _ = mirror[0]
                die(UNSUPPORTED_BLOCK_MSG, get_device_name(major, minor))
            return top_major, top_minor
        top_major, top_minor = major, minor
    return top_major, top_minor


if __name__ == '__main__':
    # Setup and use a standard locale to avoid localized scripting output
    locale.setlocale(locale.LC_ALL, 'C')

    toolname=sys.argv[0]

    if toolname == "chreipl_helper.device-mapper":
        if len(sys.argv) <= 1:
            die("Usage: %s <major:minor of target device>", toolname)
        r = re.match(r'^\s*(\d+)\s*:\s*(\d+)\s*$', sys.argv[1])
        if not r:
            die("Usage: %s <major:minor of target device>", toolname)
        major, minor = int(r.group(1)), int(r.group(2))
        phy_maj, phy_min, _, _ = get_physical_device(major, minor)
        print("{}:{}".format(phy_maj, phy_min))
        sys.exit(0)

    if len(sys.argv) <= 1:
        die("Usage: %s <target dir> or <maj:min of target device>", toolname)

    check_tools()

    r = re.match(r'^\s*(\d+)\s*:\s*(\d+)\s*$', sys.argv[1])
    if r:
        major, minor = int(r.group(1)), int(r.group(2))
        phy_maj, phy_min, phy_offset, target_list = \
                get_physical_device(major, minor)
    else:
        phy_maj, phy_min, phy_offset, target_list = \
                get_physical_device_dir(sys.argv[1])

    phy_type, phy_blksize, phy_geometry, phy_bootsectors, phy_partstart = \
            get_device_characteristics(phy_maj, phy_min)

    if phy_partstart > 0:
        # Only the partition of the physical device is mapped so only the
        # physical device can provide access to the boot record
        base_major, base_minor = \
                get_partition_base(phy_type, phy_maj, phy_min)
        # Check for mirror
        mirror = [t for t in target_list if t[2].type == "mirror"]
        if len(mirror) > 0:
            major, minor, _ = mirror[0]
            die(UNSUPPORTED_BLOCK_MSG, get_device_name(major, minor))
        # Adjust filesystem offset
        phy_offset += phy_partstart * (phy_blksize / SECTOR_SIZE)
        phy_partstart = 0
        # Update device geometry
        _, _, phy_geometry, _, _ = \
                get_device_characteristics(base_major, base_minor)
    else:
        # All of the device is mapped, so the base device is the top most dm
        # device which provides access to boot sectors
        base_major, base_minor = \
                get_target_base(phy_maj, phy_min, 0, phy_bootsectors, target_list)

    # Check for valid offset of filesystem
    if ((phy_offset % (phy_blksize / SECTOR_SIZE)) != 0):
        die("Filesystem not aligned on physical block size")

    # Print resulting information
    print("targetbase={}:{}".format(base_major, base_minor))
    print("targettype={}".format(phy_type))
    if phy_geometry:
        print("targetgeometry={}".format(phy_geometry))
    print("targetblocksize={}".format(phy_blksize))
    print("targetoffset={}".format(int(phy_offset / (phy_blksize / SECTOR_SIZE))))
